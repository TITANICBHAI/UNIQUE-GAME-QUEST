import { Particle } from './Particle';
import { Plant } from './Plant';

export class Renderer {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private width: number;
  private height: number;
  private universePhase: number = 0;
  private starField: {x: number, y: number, size: number, brightness: number}[] = [];
  private galaxies: {x: number, y: number, size: number, rotation: number, type: string}[] = [];
  private cosmicDust: {x: number, y: number, size: number, color: string}[] = [];
  
  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    const context = canvas.getContext('2d');
    if (!context) {
      throw new Error('Could not get 2D context from canvas');
    }
    this.ctx = context;
    this.width = canvas.width;
    this.height = canvas.height;
    
    // Generate star field for later phases
    this.initializeCosmicObjects();
  }
  
  // Initialize cosmic visualization elements
  private initializeCosmicObjects() {
    // Generate stars with deterministic positioning
    for (let i = 0; i < 200; i++) {
      this.starField.push({
        x: (Math.sin(i * 123.45) * 0.5 + 0.5) * this.width,
        y: (Math.cos(i * 67.89) * 0.5 + 0.5) * this.height,
        size: 0.5 + Math.sin(i * 45.67) * 1.5,
        brightness: 0.5 + Math.sin(i * 89.12) * 0.4
      });
    }
    
    // Generate galaxies for later phases
    for (let i = 0; i < 5; i++) {
      const types = ['spiral', 'elliptical', 'irregular'];
      this.galaxies.push({
        x: (Math.sin(i * 271.32) * 0.4 + 0.5) * this.width,
        y: (Math.cos(i * 91.57) * 0.4 + 0.5) * this.height,
        size: 50 + Math.sin(i * 45.67) * 30,
        rotation: Math.sin(i * 67.89) * Math.PI,
        type: types[i % types.length]
      });
    }
    
    // Generate cosmic dust clouds
    for (let i = 0; i < 15; i++) {
      const colors = ['rgba(255,100,100,0.02)', 'rgba(100,150,255,0.02)', 'rgba(180,100,255,0.02)', 'rgba(255,200,100,0.02)'];
      this.cosmicDust.push({
        x: (Math.sin(i * 123.45) * 0.6 + 0.5) * this.width,
        y: (Math.cos(i * 67.89) * 0.6 + 0.5) * this.height,
        size: 100 + Math.sin(i * 45.67) * 80,
        color: colors[i % colors.length]
      });
    }
  }
  
  // Update the cosmic phase to match game state
  setUniversePhase(phase: number) {
    this.universePhase = phase;
  }
  
  clear() {
    // Draw background based on universe phase
    if (this.universePhase <= 0) {
      // The Void - Almost complete emptiness
      this.renderVoidBackground();
    } 
    else if (this.universePhase === 1) {
      // Quantum Foam phase - subtle quantum fluctuations
      this.renderQuantumFoamBackground();
    }
    else if (this.universePhase === 2) {
      // Big Bang - explosive energy
      this.renderBigBangBackground();
    }
    else if (this.universePhase <= 4) {
      // Early universe - hot plasma and particle formation
      this.renderEarlyUniverseBackground();
    }
    else if (this.universePhase <= 6) {
      // Star formation and cosmic structure
      this.renderCosmicStructureBackground();
    }
    else {
      // Later phases - complex universe
      this.renderMatureUniverseBackground();
    }
  }
  
  private renderVoidBackground() {
    // The Void - almost complete black with subtle quantum fluctuations
    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
    gradient.addColorStop(0, '#020209'); // Deep void at top
    gradient.addColorStop(0.5, '#010106'); // Nearly black in the middle
    gradient.addColorStop(1, '#000003'); // Almost pure black at bottom
    
    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.width, this.height);
    
    // Subtle quantum fluctuations - almost invisible
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * this.width;
      const y = Math.random() * this.height;
      const size = Math.random() * 20 + 5;
      
      // Create quantum fluctuation
      const flickerIntensity = Math.sin(Date.now() * 0.01 + i) * 0.015 + 0.015;
      
      const fluctGradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
      fluctGradient.addColorStop(0, `rgba(30, 10, 60, ${flickerIntensity})`);
      fluctGradient.addColorStop(0.5, `rgba(20, 5, 40, ${flickerIntensity/2})`);
      fluctGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      
      this.ctx.fillStyle = fluctGradient;
      this.ctx.beginPath();
      this.ctx.arc(x, y, size, 0, Math.PI * 2);
      this.ctx.fill();
    }
  }
  
  private renderQuantumFoamBackground() {
    // Quantum Foam - increasing fluctuations and energy
    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
    gradient.addColorStop(0, '#05051A'); // Deep blue-purple at top 
    gradient.addColorStop(0.5, '#030310'); // Deep blue-black in the middle
    gradient.addColorStop(1, '#020209'); // Very dark at bottom
    
    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.width, this.height);
    
    // Quantum foam visualization - more noticeable fluctuations
    for (let i = 0; i < 40; i++) {
      const x = (Math.sin(i * 123.45 + Date.now() * 0.0001) * 0.5 + 0.5) * this.width;
      const y = (Math.cos(i * 67.89 + Date.now() * 0.0001) * 0.5 + 0.5) * this.height;
      const size = Math.random() * 30 + 10;
      
      // Fluctuating intensity
      const flickerIntensity = Math.sin(Date.now() * 0.003 + i) * 0.04 + 0.04;
      
      const foamGradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
      foamGradient.addColorStop(0, `rgba(70, 40, 100, ${flickerIntensity})`);
      foamGradient.addColorStop(0.6, `rgba(40, 20, 80, ${flickerIntensity/2})`);
      foamGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      
      this.ctx.fillStyle = foamGradient;
      this.ctx.beginPath();
      this.ctx.arc(x, y, size, 0, Math.PI * 2);
      this.ctx.fill();
    }
    
    // Add subtle quantum wave patterns
    this.ctx.strokeStyle = 'rgba(100, 50, 200, 0.03)';
    this.ctx.lineWidth = 2;
    
    for (let i = 0; i < 5; i++) {
      const yOffset = this.height * (i / 5) + Math.sin(Date.now() * 0.001 + i) * 20;
      
      this.ctx.beginPath();
      for (let x = 0; x < this.width; x += 5) {
        const waveHeight = Math.sin(x * 0.02 + Date.now() * 0.001 + i) * 10;
        if (x === 0) {
          this.ctx.moveTo(x, yOffset + waveHeight);
        } else {
          this.ctx.lineTo(x, yOffset + waveHeight);
        }
      }
      this.ctx.stroke();
    }
  }
  
  private renderBigBangBackground() {
    // Big Bang - explosive energy emanating from center
    // Create explosive gradient from white hot center
    const centerX = this.width / 2;
    const centerY = this.height / 2;
    const explosionRadius = this.width * (0.3 + Math.sin(Date.now() * 0.001) * 0.05);
    
    const explosionGradient = this.ctx.createRadialGradient(
      centerX, centerY, 0,
      centerX, centerY, explosionRadius
    );
    
    // Hot white center to fiery oranges and reds, then cosmic background
    explosionGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
    explosionGradient.addColorStop(0.1, 'rgba(255, 220, 150, 0.8)');
    explosionGradient.addColorStop(0.2, 'rgba(255, 150, 50, 0.7)');
    explosionGradient.addColorStop(0.4, 'rgba(200, 60, 20, 0.5)');
    explosionGradient.addColorStop(0.6, 'rgba(100, 30, 80, 0.3)');
    explosionGradient.addColorStop(0.8, 'rgba(50, 15, 60, 0.2)');
    explosionGradient.addColorStop(1, 'rgba(20, 10, 30, 0.1)');
    
    // Fill the entire canvas with the expanding explosion
    this.ctx.fillStyle = explosionGradient;
    this.ctx.fillRect(0, 0, this.width, this.height);
    
    // Add energy rays shooting outward
    const rayCount = 30;
    this.ctx.strokeStyle = 'rgba(255, 255, 200, 0.5)';
    this.ctx.lineWidth = 2;
    
    for (let i = 0; i < rayCount; i++) {
      const angle = (i / rayCount) * Math.PI * 2;
      const length = explosionRadius * 1.2 * (0.7 + Math.random() * 0.5);
      const endX = centerX + Math.cos(angle) * length;
      const endY = centerY + Math.sin(angle) * length;
      
      this.ctx.beginPath();
      this.ctx.moveTo(centerX, centerY);
      this.ctx.lineTo(endX, endY);
      this.ctx.stroke();
    }
    
    // Add energy particles
    for (let i = 0; i < 100; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * explosionRadius;
      const x = centerX + Math.cos(angle) * distance;
      const y = centerY + Math.sin(angle) * distance;
      const size = 1 + Math.random() * 3;
      
      // Color based on distance from center (hottest at center)
      const distanceFactor = distance / explosionRadius;
      let particleColor;
      
      if (distanceFactor < 0.2) {
        particleColor = 'rgba(255, 255, 255, 0.8)';
      } else if (distanceFactor < 0.5) {
        particleColor = 'rgba(255, 220, 100, 0.7)';
      } else {
        particleColor = 'rgba(255, 150, 50, 0.6)';
      }
      
      this.ctx.fillStyle = particleColor;
      this.ctx.beginPath();
      this.ctx.arc(x, y, size, 0, Math.PI * 2);
      this.ctx.fill();
    }
  }
  
  private renderEarlyUniverseBackground() {
    // Early universe - hot plasma and expanding space
    // Gradient background representing cooling plasma
    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
    gradient.addColorStop(0, '#1A0B30'); // Deep purple-blue at top
    gradient.addColorStop(0.3, '#120940'); // Purple in upper middle
    gradient.addColorStop(0.7, '#0A0730'); // Deeper blue-purple in lower middle
    gradient.addColorStop(1, '#050520'); // Dark at bottom
    
    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.width, this.height);
    
    // Draw cosmic plasma - dynamic and fluid
    const plasmaFields = 8;
    for (let i = 0; i < plasmaFields; i++) {
      const x = this.width * (i / plasmaFields) + (Math.sin(Date.now() * 0.0001 + i) * this.width * 0.1);
      const y = this.height * 0.5 + (Math.cos(Date.now() * 0.0001 + i) * this.height * 0.3);
      const size = Math.min(this.width, this.height) * (0.2 + i * 0.1);
      
      // Create plasma gradient
      const plasmaGradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
      
      // Reddish-orange plasma colors (hotter)
      plasmaGradient.addColorStop(0, `rgba(255, 150, 50, 0.05)`);
      plasmaGradient.addColorStop(0.4, `rgba(200, 100, 40, 0.04)`);
      plasmaGradient.addColorStop(0.7, `rgba(150, 50, 70, 0.03)`);
      plasmaGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      
      this.ctx.fillStyle = plasmaGradient;
      this.ctx.beginPath();
      this.ctx.arc(x, y, size, 0, Math.PI * 2);
      this.ctx.fill();
    }
    
    // Beginning of particle formation - tiny bright dots
    for (let i = 0; i < 200; i++) {
      const x = Math.random() * this.width;
      const y = Math.random() * this.height;
      const size = 0.5 + Math.random() * 1;
      
      // Particle flicker effect
      const flicker = 0.3 + Math.sin(Date.now() * 0.002 + i * 10) * 0.3;
      this.ctx.fillStyle = `rgba(255, 220, 180, ${flicker})`;
      
      this.ctx.beginPath();
      this.ctx.arc(x, y, size, 0, Math.PI * 2);
      this.ctx.fill();
    }
  }
  
  private renderCosmicStructureBackground() {
    // Cosmic structure forming - stars, galaxies beginning to form
    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
    gradient.addColorStop(0, '#0B0B2F'); // Deep blue at top
    gradient.addColorStop(0.4, '#071038'); // Mid blue-purple
    gradient.addColorStop(0.8, '#05071F'); // Dark blue-black
    gradient.addColorStop(1, '#030311'); // Almost black at bottom
    
    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.width, this.height);
    
    // Draw cosmic web structures - dark matter filaments
    this.ctx.strokeStyle = 'rgba(80, 100, 180, 0.05)';
    this.ctx.lineWidth = 8;
    
    // Create a web-like structure
    const webPoints = 8;
    const points = [];
    
    // Generate web junction points
    for (let i = 0; i < webPoints; i++) {
      points.push({
        x: (Math.sin(i * 1.37) * 0.4 + 0.5) * this.width,
        y: (Math.cos(i * 2.43) * 0.4 + 0.5) * this.height
      });
    }
    
    // Connect the web points
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        // Only connect some points, not all-to-all
        if (Math.sin(i * j) > 0.3) {
          this.ctx.beginPath();
          this.ctx.moveTo(points[i].x, points[i].y);
          this.ctx.lineTo(points[j].x, points[j].y);
          this.ctx.stroke();
        }
      }
    }
    
    // Draw subtle nebula effects
    const nebulaCount = 5;
    for (let i = 0; i < nebulaCount; i++) {
      const x = this.width * (i / nebulaCount) + (Math.sin(Date.now() * 0.0001 + i) * this.width * 0.1);
      const y = this.height * 0.5 + (Math.cos(Date.now() * 0.0001 + i) * this.height * 0.2);
      const size = Math.min(this.width, this.height) * (0.2 + i * 0.15);
      
      // Create nebula gradient
      const nebulaGradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
      
      // Random hue for each nebula
      const hue = (i * 60 + Math.sin(Date.now() * 0.0005) * 20) % 360;
      nebulaGradient.addColorStop(0, `hsla(${hue}, 80%, 30%, 0.04)`);
      nebulaGradient.addColorStop(0.5, `hsla(${hue}, 70%, 20%, 0.03)`);
      nebulaGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      
      this.ctx.fillStyle = nebulaGradient;
      this.ctx.beginPath();
      this.ctx.arc(x, y, size, 0, Math.PI * 2);
      this.ctx.fill();
    }
    
    // Draw stars - brighter ones for this phase
    for (const star of this.starField) {
      // Twinkling effect based on time
      const twinkle = star.brightness + Math.sin(Date.now() * 0.002 + star.x * 0.01) * 0.2;
      
      this.ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
      this.ctx.beginPath();
      this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
      this.ctx.fill();
      
      // Add glow to brighter stars
      if (star.size > 1.2) {
        const glowSize = star.size * 3;
        const glowGradient = this.ctx.createRadialGradient(
          star.x, star.y, 0,
          star.x, star.y, glowSize
        );
        
        glowGradient.addColorStop(0, `rgba(200, 220, 255, ${twinkle * 0.3})`);
        glowGradient.addColorStop(0.5, `rgba(150, 180, 255, ${twinkle * 0.15})`);
        glowGradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
        
        this.ctx.fillStyle = glowGradient;
        this.ctx.beginPath();
        this.ctx.arc(star.x, star.y, glowSize, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }
  }
  
  private renderMatureUniverseBackground() {
    // Mature universe - galaxies, planets, complex structures
    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
    gradient.addColorStop(0, '#0A0A20'); // Deep space blue at top
    gradient.addColorStop(0.4, '#050525'); // Dark blue in middle
    gradient.addColorStop(0.8, '#030318'); // Very dark blue lower
    gradient.addColorStop(1, '#020210'); // Almost black at bottom
    
    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.width, this.height);
    
    // Draw cosmic dust
    for (const dust of this.cosmicDust) {
      // Subtle movement
      const x = dust.x + Math.sin(Date.now() * 0.0001 + dust.x) * 10;
      const y = dust.y + Math.cos(Date.now() * 0.0001 + dust.y) * 10;
      
      const dustGradient = this.ctx.createRadialGradient(x, y, 0, x, y, dust.size);
      dustGradient.addColorStop(0, dust.color);
      dustGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      
      this.ctx.fillStyle = dustGradient;
      this.ctx.beginPath();
      this.ctx.arc(x, y, dust.size, 0, Math.PI * 2);
      this.ctx.fill();
    }
    
    // Draw galaxies
    for (const galaxy of this.galaxies) {
      this.ctx.save();
      this.ctx.translate(galaxy.x, galaxy.y);
      this.ctx.rotate(galaxy.rotation + Date.now() * 0.00005); // Slow rotation
      
      if (galaxy.type === 'spiral') {
        this.drawSpiralGalaxy(galaxy.size);
      } else if (galaxy.type === 'elliptical') {
        this.drawEllipticalGalaxy(galaxy.size);
      } else {
        this.drawIrregularGalaxy(galaxy.size);
      }
      
      this.ctx.restore();
    }
    
    // Draw stars in the background
    for (const star of this.starField) {
      // Twinkling effect based on time
      const twinkle = star.brightness + Math.sin(Date.now() * 0.002 + star.x * 0.01) * 0.2;
      
      this.ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
      this.ctx.beginPath();
      this.ctx.arc(star.x, star.y, star.size * 0.6, 0, Math.PI * 2);
      this.ctx.fill();
    }
  }
  
  // Galaxy drawing methods
  private drawSpiralGalaxy(size: number) {
    // Draw the galactic core
    const coreGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.3);
    coreGradient.addColorStop(0, 'rgba(255, 250, 220, 0.3)');
    coreGradient.addColorStop(0.5, 'rgba(255, 220, 180, 0.2)');
    coreGradient.addColorStop(1, 'rgba(200, 150, 100, 0.05)');
    
    this.ctx.fillStyle = coreGradient;
    this.ctx.beginPath();
    this.ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Draw spiral arms
    const armCount = 2;
    const starCount = 100;
    
    for (let a = 0; a < armCount; a++) {
      const startAngle = (a / armCount) * Math.PI * 2;
      
      for (let i = 0; i < starCount; i++) {
        const distance = (i / starCount) * size;
        const angle = startAngle + (i / starCount) * Math.PI * 2;
        
        const x = Math.cos(angle) * distance;
        const y = Math.sin(angle) * distance;
        const starSize = Math.random() * 1.5 + 0.5;
        
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
        this.ctx.beginPath();
        this.ctx.arc(x, y, starSize, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }
  }
  
  private drawEllipticalGalaxy(size: number) {
    // Draw elliptical galaxy with radial gradient
    const galaxyGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, size);
    galaxyGradient.addColorStop(0, 'rgba(255, 250, 220, 0.2)');
    galaxyGradient.addColorStop(0.4, 'rgba(255, 200, 150, 0.1)');
    galaxyGradient.addColorStop(0.8, 'rgba(200, 150, 100, 0.05)');
    galaxyGradient.addColorStop(1, 'rgba(150, 100, 50, 0)');
    
    this.ctx.fillStyle = galaxyGradient;
    
    // Slightly squash the elliptical shape
    this.ctx.save();
    this.ctx.scale(1, 0.7);
    this.ctx.beginPath();
    this.ctx.arc(0, 0, size, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.restore();
    
    // Add some random stars
    const starCount = 50;
    for (let i = 0; i < starCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * size * 0.9;
      
      const x = Math.cos(angle) * distance;
      const y = Math.sin(angle) * distance * 0.7; // Maintain elliptical shape
      const starSize = Math.random() * 1 + 0.5;
      
      this.ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
      this.ctx.beginPath();
      this.ctx.arc(x, y, starSize, 0, Math.PI * 2);
      this.ctx.fill();
    }
  }
  
  private drawIrregularGalaxy(size: number) {
    // Draw an irregular galaxy with cloud-like structures
    const cloudCount = 5;
    
    for (let i = 0; i < cloudCount; i++) {
      const x = (Math.sin(i * 1.2) * 0.5) * size * 0.7;
      const y = (Math.cos(i * 1.8) * 0.5) * size * 0.7;
      const cloudSize = (0.3 + Math.random() * 0.4) * size;
      
      const cloudGradient = this.ctx.createRadialGradient(x, y, 0, x, y, cloudSize);
      cloudGradient.addColorStop(0, 'rgba(255, 230, 200, 0.15)');
      cloudGradient.addColorStop(0.6, 'rgba(230, 200, 150, 0.07)');
      cloudGradient.addColorStop(1, 'rgba(200, 150, 100, 0)');
      
      this.ctx.fillStyle = cloudGradient;
      this.ctx.beginPath();
      this.ctx.arc(x, y, cloudSize, 0, Math.PI * 2);
      this.ctx.fill();
      
      // Add stars to each cloud
      const starCount = 20;
      for (let j = 0; j < starCount; j++) {
        const starAngle = Math.random() * Math.PI * 2;
        const starDistance = Math.random() * cloudSize * 0.8;
        
        const starX = x + Math.cos(starAngle) * starDistance;
        const starY = y + Math.sin(starAngle) * starDistance;
        const starSize = Math.random() * 1 + 0.5;
        
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
        this.ctx.beginPath();
        this.ctx.arc(starX, starY, starSize, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }
  }
  
  renderField(field: number[][]) {
    const cellWidth = this.width / field.length;
    const cellHeight = this.height / field[0].length;
    
    this.ctx.save();
    
    for (let i = 0; i < field.length; i++) {
      for (let j = 0; j < field[0].length; j++) {
        const value = field[i][j];
        
        // Skip rendering cells with very low energy
        if (Math.abs(value) < 0.1) continue;
        
        const x = i * cellWidth;
        const y = j * cellHeight;
        
        // Choose color based on field value
        const intensity = Math.min(255, Math.abs(value * 100));
        let color;
        
        if (value > 0) {
          // Positive values: blueish
          color = `rgba(20, ${intensity}, ${intensity * 2}, 0.1)`;
        } else {
          // Negative values: reddish
          color = `rgba(${intensity * 2}, ${intensity / 2}, ${intensity / 3}, 0.1)`;
        }
        
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x, y, cellWidth, cellHeight);
      }
    }
    
    this.ctx.restore();
  }
  
  renderParticle(particle: Particle) {
    this.ctx.save();
    
    const opacity = Math.min(1, 1 - (particle.age / particle.lifespan));
    const baseSize = 3 + particle.energy * 5;
    const pulse = Math.sin(particle.age * 8) * 0.2 + 0.8; // Pulsing effect
    
    // Choose phase-specific particle properties
    let size = baseSize;
    let coreColor, glowInnerColor, glowOuterColor;
    let waveMultiplier = 1.0;
    
    // Phase-specific appearance and behavior
    switch(this.universePhase) {
      case 0: // The Void
        // Subtle quantum fluctuations - purple/violet
        size *= 0.7; // Smaller
        coreColor = `rgba(80, 40, 120, ${opacity * 0.6})`;
        glowInnerColor = `rgba(60, 30, 100, ${opacity * 0.4})`;
        glowOuterColor = `rgba(40, 15, 60, ${opacity * 0.1})`;
        waveMultiplier = 0.3; // Subtle waves
        break;
        
      case 1: // Quantum Foam
        // More energetic fluctuations - deeper purples
        size *= 0.8;
        coreColor = `rgba(110, 60, 170, ${opacity * 0.7})`;
        glowInnerColor = `rgba(80, 40, 130, ${opacity * 0.5})`;
        glowOuterColor = `rgba(50, 20, 90, ${opacity * 0.2})`;
        waveMultiplier = 0.5;
        break;
        
      case 2: // Big Bang
        // Explosive energy - bright whites and yellows
        size *= 1.4; // Larger
        coreColor = `rgba(255, 255, 220, ${opacity * 0.9})`;
        glowInnerColor = `rgba(255, 220, 150, ${opacity * 0.7})`;
        glowOuterColor = `rgba(255, 180, 100, ${opacity * 0.3})`;
        waveMultiplier = 1.8; // Strong waves
        break;
        
      case 3: // Early Universe
      case 4: // Nucleosynthesis
        // Hot plasma - reds and oranges
        size *= 1.2;
        coreColor = `rgba(255, 150, 80, ${opacity * 0.85})`;
        glowInnerColor = `rgba(230, 100, 50, ${opacity * 0.6})`;
        glowOuterColor = `rgba(180, 60, 30, ${opacity * 0.3})`;
        waveMultiplier = 1.2;
        break;
        
      case 5: // Recombination
      case 6: // First Stars
        // Cooling particles - transition to blues/purples
        size *= 1.1;
        coreColor = `rgba(180, 170, 220, ${opacity * 0.8})`;
        glowInnerColor = `rgba(130, 140, 210, ${opacity * 0.5})`;
        glowOuterColor = `rgba(80, 100, 180, ${opacity * 0.2})`;
        waveMultiplier = 0.8;
        break;
        
      default: // Later phases
        // Cooled particles - blues and cyans
        coreColor = `rgba(140, 230, 255, ${opacity * 0.7})`;
        glowInnerColor = `rgba(100, 220, 255, ${opacity * 0.6})`;
        glowOuterColor = `rgba(30, 180, 255, ${opacity * 0.2})`;
        waveMultiplier = 0.6;
    }
    
    // Override for entangled particles
    if (particle.entangled) {
      coreColor = `rgba(255, 230, 100, ${opacity})`;
      glowInnerColor = `rgba(255, 220, 50, ${opacity * 0.8})`;
      glowOuterColor = `rgba(255, 180, 30, ${opacity * 0.3})`;
      size *= 1.2; // Slightly larger
      waveMultiplier *= 1.5; // More quantum effects
    }
    
    // Calculate wave pattern based on particle's properties and phase
    const waveOffset = Math.sin(particle.age * 5 + particle.phase) * 
                       20 * particle.energy * waveMultiplier;
    
    // Create glow effect
    const glowSize = size * 2.5;
    const glowGradient = this.ctx.createRadialGradient(
      particle.x, particle.y, 0,
      particle.x, particle.y, glowSize
    );
    
    // Apply glow colors
    glowGradient.addColorStop(0, glowInnerColor);
    glowGradient.addColorStop(0.5, glowOuterColor);
    glowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    
    // Draw glow
    this.ctx.fillStyle = glowGradient;
    this.ctx.beginPath();
    this.ctx.arc(particle.x, particle.y, glowSize, 0, Math.PI * 2);
    this.ctx.fill();
    
    // For entangled particles, add special effects
    if (particle.entangled) {
      // Entanglement rings
      this.ctx.strokeStyle = `rgba(255, 255, 100, ${opacity * pulse})`;
      this.ctx.lineWidth = 1.5;
      this.ctx.beginPath();
      this.ctx.arc(particle.x, particle.y, size * 1.8, 0, Math.PI * 2);
      this.ctx.stroke();
      
      this.ctx.beginPath();
      this.ctx.arc(particle.x, particle.y, size * 2.2, 0, Math.PI * 2);
      this.ctx.stroke();
    }
    
    // Draw particle core
    this.ctx.fillStyle = coreColor;
    
    // Draw core
    this.ctx.shadowColor = particle.entangled ? 'rgba(255, 200, 70, 0.8)' : 'rgba(30, 150, 255, 0.8)';
    this.ctx.shadowBlur = 10;
    this.ctx.beginPath();
    this.ctx.arc(particle.x, particle.y, size * pulse, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.shadowBlur = 0;
    
    // Draw wave trail with gradient
    const trailPoints = 10;
    const trailGradient = this.ctx.createLinearGradient(
      particle.x, particle.y,
      particle.x + Math.cos(particle.direction + Math.PI) * 20,
      particle.y + Math.sin(particle.direction + Math.PI) * 20
    );
    
    if (particle.entangled) {
      trailGradient.addColorStop(0, `rgba(255, 200, 70, ${opacity * 0.8})`);
      trailGradient.addColorStop(1, `rgba(255, 150, 0, 0)`);
    } else {
      trailGradient.addColorStop(0, `rgba(100, 200, 255, ${opacity * 0.8})`);
      trailGradient.addColorStop(1, `rgba(50, 100, 255, 0)`);
    }
    
    this.ctx.strokeStyle = trailGradient;
    this.ctx.lineWidth = 2;
    
    // Main trail
    this.ctx.beginPath();
    this.ctx.moveTo(particle.x, particle.y);
    
    for (let i = 1; i <= trailPoints; i++) {
      const t = i / trailPoints;
      const dist = 20 * t;
      const dx = Math.cos(particle.direction + Math.PI) * dist;
      const dy = Math.sin(particle.direction + Math.PI) * dist;
      
      const trailWave = Math.sin(particle.age * 5 - t * 5 + particle.phase) * waveOffset * (1 - t);
      const perpX = Math.cos(particle.direction + Math.PI/2) * trailWave;
      const perpY = Math.sin(particle.direction + Math.PI/2) * trailWave;
      
      this.ctx.lineTo(
        particle.x + dx + perpX, 
        particle.y + dy + perpY
      );
    }
    
    this.ctx.stroke();
    
    // Small sparkles for entangled particles
    if (particle.entangled && Math.random() < 0.3) {
      const sparkleCount = 2;
      this.ctx.fillStyle = 'rgba(255, 255, 200, 0.8)';
      
      for (let i = 0; i < sparkleCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * size * 3;
        const sparkleX = particle.x + Math.cos(angle) * distance;
        const sparkleY = particle.y + Math.sin(angle) * distance;
        const sparkleSize = 1 + Math.random();
        
        this.ctx.beginPath();
        this.ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }
    
    this.ctx.restore();
  }
  
  renderPlant(plant: Plant) {
    this.ctx.save();
    
    // Move to plant position
    this.ctx.translate(plant.x, plant.y);
    
    // Apply rotation for all cosmic bodies
    this.ctx.rotate(plant.rotation);
    
    // Extract color components for gradient
    const hueMatch = plant.color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
    let hue = 120, sat = 70, light = 50;
    
    if (hueMatch) {
      hue = parseInt(hueMatch[1]);
      sat = parseInt(hueMatch[2]);
      light = parseInt(hueMatch[3]);
    }
    
    // Render based on cosmic body type
    switch(plant.type) {
      case 'galaxy':
        this.renderGalaxy(plant, hue, sat, light);
        break;
      case 'star':
        this.renderStar(plant, hue, sat, light);
        break;
      case 'protostar':
        this.renderProtostar(plant, hue, sat, light);
        break;
      case 'planet':
        this.renderPlanet(plant, hue, sat, light);
        break;
      case 'lifeForm':
        this.renderLifeForm(plant, hue, sat, light);
        break;
      default:
        // Default to energy cluster/plant
        this.renderEnergyCluster(plant, hue, sat, light);
    }
    
    this.ctx.restore();
  }
  
  private renderEnergyCluster(plant: Plant, hue: number, sat: number, light: number) {
    // Animation effect - gentle oscillation
    const oscillation = Math.sin(plant.oscillation) * 0.05;
    
    // Create outer glow
    const outerGlow = this.ctx.createRadialGradient(0, 0, plant.size * 0.5, 0, 0, plant.size * 4);
    outerGlow.addColorStop(0, `hsla(${hue}, ${sat}%, ${light + 10}%, 0.6)`);
    outerGlow.addColorStop(0.5, `hsla(${hue}, ${sat}%, ${light}%, 0.2)`);
    outerGlow.addColorStop(1, 'rgba(0,0,0,0)');
    
    this.ctx.fillStyle = outerGlow;
    this.ctx.beginPath();
    this.ctx.arc(0, 0, plant.size * 4, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Inner core with texture
    const coreGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, plant.size);
    coreGradient.addColorStop(0, `hsla(${hue}, ${sat + 20}%, ${light + 15}%, 1)`);
    coreGradient.addColorStop(0.7, `hsla(${hue}, ${sat + 10}%, ${light + 5}%, 1)`);
    coreGradient.addColorStop(1, `hsla(${hue}, ${sat}%, ${light}%, 1)`);
    
    this.ctx.fillStyle = coreGradient;
    this.ctx.shadowColor = `hsla(${hue}, ${sat}%, ${light + 20}%, 0.8)`;
    this.ctx.shadowBlur = 15;
    this.ctx.beginPath();
    this.ctx.arc(0, 0, plant.size, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.shadowBlur = 0;
    
    // Add energy pulse rings
    const pulseSize = plant.size * (1 + Math.sin(plant.oscillation * 3) * 0.1);
    this.ctx.strokeStyle = `hsla(${hue}, ${sat + 10}%, ${light + 25}%, ${0.3 + Math.sin(plant.oscillation * 2) * 0.1})`;
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.arc(0, 0, pulseSize * 1.3, 0, Math.PI * 2);
    this.ctx.stroke();
    
    this.ctx.beginPath();
    this.ctx.arc(0, 0, pulseSize * 1.7, 0, Math.PI * 2);
    this.ctx.stroke();
    
    // Draw branches with their segments
    this.drawBranches(plant, hue, sat, light);
  }
  
  private drawBranches(plant: Plant, hue: number, sat: number, light: number) {
    // Animation effect - gentle oscillation
    const oscillation = Math.sin(plant.oscillation) * 0.05;
    
    for (const branch of plant.branches) {
      this.ctx.save();
      this.ctx.translate(branch.x, branch.y);
      
      // Apply slight rotation based on oscillation
      this.ctx.rotate(oscillation);
      
      // Draw each segment
      let prevX = 0;
      let prevY = 0;
      
      for (let i = 0; i < branch.segments.length; i++) {
        const segment = branch.segments[i];
        
        // Calculate segment width (tapers toward the end)
        const segmentWidth = branch.width * (1 - i / branch.segments.length * 0.7);
        
        // Calculate endpoint
        const endX = segment.x + Math.cos(segment.angle) * segment.length;
        const endY = segment.y + Math.sin(segment.angle) * segment.length;
        
        // Create segment gradient
        const segmentGradient = this.ctx.createLinearGradient(
          segment.x, segment.y, 
          endX, endY
        );
        
        segmentGradient.addColorStop(0, `hsla(${hue - 10}, ${sat}%, ${light + 5}%, 1)`);
        segmentGradient.addColorStop(1, `hsla(${hue + 10}, ${sat - 10}%, ${light}%, 1)`);
        
        // Draw segment as line with shadow
        this.ctx.shadowColor = `hsla(${hue}, ${sat}%, ${light + 20}%, 0.4)`;
        this.ctx.shadowBlur = 5;
        this.ctx.lineWidth = segmentWidth;
        this.ctx.lineCap = 'round';
        this.ctx.strokeStyle = segmentGradient;
        
        this.ctx.beginPath();
        this.ctx.moveTo(segment.x, segment.y);
        this.ctx.lineTo(endX, endY);
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        
        // Draw a decoration at the segment joints
        if (i > 0) {
          const jointGradient = this.ctx.createRadialGradient(
            segment.x, segment.y, 0,
            segment.x, segment.y, segmentWidth * 0.8
          );
          
          jointGradient.addColorStop(0, `hsla(${hue + 15}, ${sat + 10}%, ${light + 15}%, 1)`);
          jointGradient.addColorStop(1, `hsla(${hue}, ${sat}%, ${light}%, 1)`);
          
          this.ctx.fillStyle = jointGradient;
          this.ctx.beginPath();
          this.ctx.arc(segment.x, segment.y, segmentWidth * 0.8, 0, Math.PI * 2);
          this.ctx.fill();
        }
        
        prevX = endX;
        prevY = endY;
      }
      
      // Draw energy emission at tip of branch
      if (branch.segments.length > 0) {
        const lastSegment = branch.segments[branch.segments.length - 1];
        const endX = lastSegment.x + Math.cos(lastSegment.angle) * lastSegment.length;
        const endY = lastSegment.y + Math.sin(lastSegment.angle) * lastSegment.length;
        
        // Draw energy node at branch tip
        const emissionCount = 5;
        const emissionSize = branch.width * 1.5;
        
        for (let i = 0; i < emissionCount; i++) {
          const emissionAngle = lastSegment.angle + (i / emissionCount) * Math.PI * 2;
          
          // Glow effect
          const emissionGradient = this.ctx.createRadialGradient(
            endX, endY, 0,
            endX, endY, emissionSize
          );
          
          emissionGradient.addColorStop(0, `hsla(${hue + 20}, ${sat}%, ${light + 25}%, 0.9)`);
          emissionGradient.addColorStop(0.7, `hsla(${hue}, ${sat}%, ${light + 10}%, 0.4)`);
          emissionGradient.addColorStop(1, `hsla(${hue - 20}, ${sat - 20}%, ${light}%, 0)`);
          
          this.ctx.fillStyle = emissionGradient;
          
          // Draw emission
          this.ctx.beginPath();
          this.ctx.ellipse(
            endX + Math.cos(emissionAngle) * emissionSize * 0.7,
            endY + Math.sin(emissionAngle) * emissionSize * 0.7,
            emissionSize, emissionSize * 0.5,
            emissionAngle, 0, Math.PI * 2
          );
          this.ctx.fill();
        }
      }
      
      this.ctx.restore();
    }
  }
  
  private renderProtostar(plant: Plant, hue: number, sat: number, light: number) {
    // Protostars are emerging stars - more energy emissions
    
    // Draw a central glowing core
    const coreGradient = this.ctx.createRadialGradient(
      0, 0, 0,
      0, 0, plant.size
    );
    
    // Protostar colors - reddish orange
    coreGradient.addColorStop(0, `hsla(${hue + 20}, ${Math.min(100, sat + 20)}%, ${Math.min(100, light + 20)}%, 1)`);
    coreGradient.addColorStop(0.6, `hsla(${hue}, ${sat}%, ${light}%, 0.9)`);
    coreGradient.addColorStop(1, `hsla(${hue - 20}, ${Math.max(0, sat - 20)}%, ${Math.max(0, light - 20)}%, 0.7)`);
    
    this.ctx.fillStyle = coreGradient;
    this.ctx.shadowColor = `hsla(${hue}, ${Math.min(100, sat + 10)}%, ${Math.min(100, light + 15)}%, 0.8)`;
    this.ctx.shadowBlur = 20;
    this.ctx.beginPath();
    this.ctx.arc(0, 0, plant.size, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.shadowBlur = 0;
    
    // Add energy emissions (corona-like)
    const emissionCount = 16;
    
    for (let i = 0; i < emissionCount; i++) {
      const angle = (i / emissionCount) * Math.PI * 2;
      const length = plant.size * (1.2 + Math.sin(plant.age * 2 + i) * 0.3);
      
      this.ctx.strokeStyle = `hsla(${hue + 15}, ${Math.min(100, sat + 10)}%, ${Math.min(100, light + 10)}%, 0.5)`;
      this.ctx.lineWidth = 1 + Math.random();
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0);
      this.ctx.lineTo(
        Math.cos(angle) * length,
        Math.sin(angle) * length
      );
      this.ctx.stroke();
    }
    
    // Add pulsing outer glow
    const pulseSize = plant.size * 2 * (1 + Math.sin(plant.age) * 0.2);
    const outerGlow = this.ctx.createRadialGradient(
      0, 0, plant.size,
      0, 0, pulseSize
    );
    
    outerGlow.addColorStop(0, `hsla(${hue}, ${sat}%, ${light}%, 0.5)`);
    outerGlow.addColorStop(0.5, `hsla(${hue}, ${Math.max(0, sat - 10)}%, ${light}%, 0.2)`);
    outerGlow.addColorStop(1, 'rgba(0,0,0,0)');
    
    this.ctx.fillStyle = outerGlow;
    this.ctx.beginPath();
    this.ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Draw energy branches if any
    if (plant.branches.length > 0) {
      this.drawBranches(plant, hue, sat, light);
    }
  }
  
  private renderStar(plant: Plant, hue: number, sat: number, light: number) {
    // Stars have a bright core with a corona and possibly orbiting planets
    
    // Draw main star body with glow
    const starGlow = this.ctx.createRadialGradient(
      0, 0, 0,
      0, 0, plant.size * 3
    );
    
    // Outer glow
    starGlow.addColorStop(0, `hsla(${hue}, ${sat}%, ${light}%, 0.6)`);
    starGlow.addColorStop(0.4, `hsla(${hue}, ${sat}%, ${Math.min(100, light + 10)}%, 0.3)`);
    starGlow.addColorStop(0.7, `hsla(${hue}, ${Math.max(0, sat - 20)}%, ${Math.min(100, light + 5)}%, 0.1)`);
    starGlow.addColorStop(1, `hsla(${hue}, ${Math.max(0, sat - 30)}%, ${light}%, 0)`);
    
    this.ctx.fillStyle = starGlow;
    this.ctx.beginPath();
    this.ctx.arc(0, 0, plant.size * 3, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Inner bright core
    const coreGradient = this.ctx.createRadialGradient(
      0, 0, 0,
      0, 0, plant.size
    );
    
    // Star color based on temperature (hue)
    coreGradient.addColorStop(0, `hsla(${hue}, ${Math.min(100, sat + 10)}%, ${Math.min(100, light + 25)}%, 1)`);
    coreGradient.addColorStop(0.7, `hsla(${hue}, ${sat}%, ${Math.min(100, light + 5)}%, 1)`);
    coreGradient.addColorStop(1, `hsla(${hue}, ${Math.max(0, sat - 10)}%, ${light}%, 0.9)`);
    
    // Add bright glow effect
    this.ctx.shadowColor = `hsla(${hue}, ${Math.min(100, sat + 10)}%, ${Math.min(100, light + 15)}%, 0.8)`;
    this.ctx.shadowBlur = 30;
    this.ctx.fillStyle = coreGradient;
    this.ctx.beginPath();
    this.ctx.arc(0, 0, plant.size, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.shadowBlur = 0;
    
    // Surface details - solar prominences
    if (plant.size > 7) {
      const prominenceCount = 4 + Math.floor(Math.random() * 3);
      
      for (let i = 0; i < prominenceCount; i++) {
        const angle = (i / prominenceCount) * Math.PI * 2 + plant.age * 0.1;
        const size = plant.size * (0.1 + Math.random() * 0.2);
        const distance = plant.size * (0.9 + Math.random() * 0.2);
        
        const x = Math.cos(angle) * distance;
        const y = Math.sin(angle) * distance;
        
        const prominenceGradient = this.ctx.createRadialGradient(
          x, y, 0,
          x, y, size
        );
        
        prominenceGradient.addColorStop(0, `hsla(${hue + 10}, ${Math.min(100, sat + 20)}%, ${Math.min(100, light + 10)}%, 0.8)`);
        prominenceGradient.addColorStop(1, `hsla(${hue}, ${sat}%, ${light}%, 0)`);
        
        this.ctx.fillStyle = prominenceGradient;
        this.ctx.beginPath();
        this.ctx.arc(x, y, size, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }
    
    // Draw orbiting planets/satellites
    for (const satellite of plant.satellites) {
      const pos = satellite.getPosition(0, 0);
      
      // Draw orbit path (faintly)
      this.ctx.strokeStyle = `rgba(255, 255, 255, 0.05)`;
      this.ctx.setLineDash([2, 4]);
      this.ctx.lineWidth = 0.5;
      this.ctx.beginPath();
      this.ctx.arc(0, 0, satellite.distance, 0, Math.PI * 2);
      this.ctx.stroke();
      this.ctx.setLineDash([]);
      
      // Draw the satellite/planet
      const planetGradient = this.ctx.createRadialGradient(
        pos.x, pos.y, 0,
        pos.x, pos.y, satellite.size
      );
      
      // Extract satellite color components
      const satColorRegex = /hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/;
      const satMatches = satellite.color.match(satColorRegex);
      
      if (satMatches) {
        const satHue = parseInt(satMatches[1]);
        const satSat = parseInt(satMatches[2]);
        const satLight = parseInt(satMatches[3]);
        
        planetGradient.addColorStop(0, `hsla(${satHue}, ${satSat}%, ${Math.min(100, satLight + 15)}%, 1)`);
        planetGradient.addColorStop(0.8, `hsla(${satHue}, ${satSat}%, ${satLight}%, 1)`);
        planetGradient.addColorStop(1, `hsla(${satHue}, ${Math.max(0, satSat - 10)}%, ${Math.max(0, satLight - 10)}%, 0.9)`);
      } else {
        // Fallback
        planetGradient.addColorStop(0, 'rgba(200, 200, 200, 1)');
        planetGradient.addColorStop(0.8, 'rgba(150, 150, 150, 1)');
        planetGradient.addColorStop(1, 'rgba(100, 100, 100, 0.9)');
      }
      
      this.ctx.fillStyle = planetGradient;
      this.ctx.beginPath();
      this.ctx.arc(pos.x, pos.y, satellite.size, 0, Math.PI * 2);
      this.ctx.fill();
      
      // Draw rings if this planet has them
      if (satellite.hasRings) {
        this.ctx.save();
        this.ctx.translate(pos.x, pos.y);
        this.ctx.rotate(Math.PI / 4); // Tilt the rings
        
        this.ctx.strokeStyle = satellite.ringColor;
        this.ctx.lineWidth = satellite.size * 0.4;
        
        this.ctx.beginPath();
        this.ctx.ellipse(0, 0, satellite.ringSize, satellite.ringSize * 0.3, 0, 0, Math.PI * 2);
        this.ctx.stroke();
        
        this.ctx.restore();
      }
    }
  }
  
  private renderGalaxy(plant: Plant, hue: number, sat: number, light: number) {
    // Galaxies are large with spiral arms and stars
    
    // Draw galaxy core
    const coreGradient = this.ctx.createRadialGradient(
      0, 0, 0,
      0, 0, plant.size * 0.4
    );
    
    coreGradient.addColorStop(0, `hsla(${hue}, ${Math.min(100, sat + 10)}%, ${Math.min(100, light + 10)}%, 0.9)`);
    coreGradient.addColorStop(0.7, `hsla(${hue}, ${sat}%, ${light}%, 0.7)`);
    coreGradient.addColorStop(1, `hsla(${hue}, ${Math.max(0, sat - 10)}%, ${Math.max(0, light - 10)}%, 0.5)`);
    
    this.ctx.shadowColor = `hsla(${hue}, ${Math.min(100, sat + 10)}%, ${Math.min(100, light + 10)}%, 0.5)`;
    this.ctx.shadowBlur = 15;
    this.ctx.fillStyle = coreGradient;
    this.ctx.beginPath();
    this.ctx.arc(0, 0, plant.size * 0.4, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.shadowBlur = 0;
    
    // Draw spiral arms
    const armCount = 2 + Math.floor(Math.random() * 2);
    const spiralTightness = 0.7; // Higher = tighter spiral
    const rotations = 1.5; // Number of rotations for each arm
    
    for (let arm = 0; arm < armCount; arm++) {
      const startAngle = (arm / armCount) * Math.PI * 2;
      const armWidth = plant.size * 0.15;
      
      // Create gradient for spiral arm
      const armGradient = this.ctx.createLinearGradient(
        0, 0,
        plant.size * Math.cos(startAngle),
        plant.size * Math.sin(startAngle)
      );
      
      armGradient.addColorStop(0, `hsla(${hue}, ${Math.max(0, sat - 10)}%, ${Math.max(0, light - 5)}%, 0.7)`);
      armGradient.addColorStop(0.5, `hsla(${hue}, ${sat}%, ${light}%, 0.3)`);
      armGradient.addColorStop(1, `hsla(${hue}, ${Math.min(100, sat + 10)}%, ${Math.min(100, light + 5)}%, 0.1)`);
      
      this.ctx.strokeStyle = armGradient;
      this.ctx.lineWidth = armWidth;
      this.ctx.lineCap = 'round';
      
      // Draw the arm as a spiral
      this.ctx.beginPath();
      
      const steps = 100;
      let prevX = 0, prevY = 0;
      let firstPoint = true;
      
      for (let i = 0; i < steps; i++) {
        const t = i / steps;
        const angle = startAngle + t * Math.PI * 2 * rotations;
        const radius = plant.size * t;
        
        const x = radius * Math.cos(angle + t * spiralTightness);
        const y = radius * Math.sin(angle + t * spiralTightness);
        
        if (firstPoint) {
          this.ctx.moveTo(x, y);
          firstPoint = false;
        } else {
          this.ctx.lineTo(x, y);
        }
        
        prevX = x;
        prevY = y;
      }
      
      this.ctx.stroke();
      
      // Add some random stars along the arms
      for (let i = 0; i < 30; i++) {
        const t = Math.random();
        const angle = startAngle + t * Math.PI * 2 * rotations;
        const radius = plant.size * t * 0.9;
        
        const x = radius * Math.cos(angle + t * spiralTightness);
        const y = radius * Math.sin(angle + t * spiralTightness);
        const starSize = 0.5 + Math.random();
        
        this.ctx.fillStyle = `rgba(255, 255, 255, ${0.4 + Math.random() * 0.4})`;
        this.ctx.beginPath();
        this.ctx.arc(x, y, starSize, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }
    
    // Draw stars within the galaxy (satellites)
    for (const satellite of plant.satellites) {
      const pos = satellite.getPosition(0, 0);
      
      // Draw the star
      const starGradient = this.ctx.createRadialGradient(
        pos.x, pos.y, 0,
        pos.x, pos.y, satellite.size * 2
      );
      
      // Extract satellite color
      const satColorRegex = /hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/;
      const satMatches = satellite.color.match(satColorRegex);
      
      if (satMatches) {
        const satHue = parseInt(satMatches[1]);
        const satSat = parseInt(satMatches[2]);
        const satLight = parseInt(satMatches[3]);
        
        starGradient.addColorStop(0, `hsla(${satHue}, ${satSat}%, ${Math.min(100, satLight + 30)}%, 1)`);
        starGradient.addColorStop(0.5, `hsla(${satHue}, ${satSat}%, ${satLight}%, 0.6)`);
        starGradient.addColorStop(1, `hsla(${satHue}, ${Math.max(0, satSat - 10)}%, ${Math.max(0, satLight - 10)}%, 0)`);
      } else {
        // Fallback
        starGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        starGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.6)');
        starGradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
      }
      
      this.ctx.fillStyle = starGradient;
      this.ctx.beginPath();
      this.ctx.arc(pos.x, pos.y, satellite.size * 2, 0, Math.PI * 2);
      this.ctx.fill();
    }
    
    // Draw overall galaxy glow
    const galaxyGlow = this.ctx.createRadialGradient(
      0, 0, plant.size * 0.5,
      0, 0, plant.size * 1.5
    );
    
    galaxyGlow.addColorStop(0, `hsla(${hue}, ${sat}%, ${light}%, 0.1)`);
    galaxyGlow.addColorStop(0.5, `hsla(${hue}, ${Math.max(0, sat - 10)}%, ${Math.min(100, light + 5)}%, 0.07)`);
    galaxyGlow.addColorStop(1, `hsla(${hue}, ${Math.max(0, sat - 20)}%, ${light}%, 0)`);
    
    this.ctx.fillStyle = galaxyGlow;
    this.ctx.beginPath();
    this.ctx.arc(0, 0, plant.size * 1.5, 0, Math.PI * 2);
    this.ctx.fill();
  }
  
  private renderPlanet(plant: Plant, hue: number, sat: number, light: number) {
    // Planets with possibly atmosphere and moons
    
    // Draw planet body with surface texture
    const planetGradient = this.ctx.createRadialGradient(
      0, 0, 0,
      0, 0, plant.size
    );
    
    planetGradient.addColorStop(0, `hsla(${hue}, ${sat}%, ${Math.min(100, light + 10)}%, 1)`);
    planetGradient.addColorStop(0.8, `hsla(${hue}, ${Math.max(0, sat - 5)}%, ${light}%, 1)`);
    planetGradient.addColorStop(1, `hsla(${hue}, ${Math.max(0, sat - 15)}%, ${Math.max(0, light - 10)}%, 0.9)`);
    
    this.ctx.fillStyle = planetGradient;
    this.ctx.beginPath();
    this.ctx.arc(0, 0, plant.size, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Draw atmosphere for earth-like planets (high habitability)
    if (plant.habitability > 0.3) {
      const atmosphereSize = plant.size * (1 + plant.habitability * 0.3);
      const atmosphereGradient = this.ctx.createRadialGradient(
        0, 0, plant.size * 0.9,
        0, 0, atmosphereSize
      );
      
      // Blue-ish atmosphere for habitable planets
      let atmosphereHue = 200; // Default blue
      let atmosphereOpacity = 0.4;
      
      if (plant.lifeComplexity > 0) {
        // Green tint for planets with life
        atmosphereHue = 160 + Math.min(plant.lifeComplexity * 40, 35);
        atmosphereOpacity = 0.4 + plant.lifeComplexity * 0.2;
      }
      
      atmosphereGradient.addColorStop(0, `hsla(${atmosphereHue}, 80%, 70%, ${atmosphereOpacity})`);
      atmosphereGradient.addColorStop(0.7, `hsla(${atmosphereHue}, 70%, 60%, ${atmosphereOpacity * 0.6})`);
      atmosphereGradient.addColorStop(1, `hsla(${atmosphereHue}, 60%, 50%, 0)`);
      
      this.ctx.fillStyle = atmosphereGradient;
      this.ctx.beginPath();
      this.ctx.arc(0, 0, atmosphereSize, 0, Math.PI * 2);
      this.ctx.fill();
    }
    
    // Draw surface features - continents, oceans, etc.
    const featureCount = 3 + Math.floor(Math.random() * 4);
    
    for (let i = 0; i < featureCount; i++) {
      const angle = (i / featureCount) * Math.PI * 2 + plant.rotation;
      const size = plant.size * (0.3 + Math.random() * 0.4);
      const distance = plant.size * (0.2 + Math.random() * 0.5);
      
      const x = Math.cos(angle) * distance;
      const y = Math.sin(angle) * distance;
      
      // Continent/ocean color depends on planet type
      let featureHue = hue;
      let featureSat = sat;
      let featureLight = light;
      
      // Adjust color based on feature type
      if (i % 2 === 0) {
        // Land features
        featureHue = (hue + 30) % 360;
        featureLight = Math.max(30, light - 20);
      } else {
        // Water/ice features
        featureHue = (hue + 180) % 360;
        featureLight = Math.min(80, light + 20);
      }
      
      const featureGradient = this.ctx.createRadialGradient(
        x, y, 0,
        x, y, size
      );
      
      featureGradient.addColorStop(0, `hsla(${featureHue}, ${featureSat}%, ${featureLight}%, 0.7)`);
      featureGradient.addColorStop(0.6, `hsla(${featureHue}, ${Math.max(0, featureSat - 10)}%, ${featureLight}%, 0.4)`);
      featureGradient.addColorStop(1, `hsla(${featureHue}, ${Math.max(0, featureSat - 20)}%, ${featureLight}%, 0)`);
      
      this.ctx.fillStyle = featureGradient;
      this.ctx.beginPath();
      this.ctx.arc(x, y, size, 0, Math.PI * 2);
      this.ctx.fill();
    }
    
    // Draw orbiting moons
    for (const satellite of plant.satellites) {
      const pos = satellite.getPosition(0, 0);
      
      // Draw orbit path (faintly)
      this.ctx.strokeStyle = `rgba(255, 255, 255, 0.07)`;
      this.ctx.setLineDash([1, 3]);
      this.ctx.lineWidth = 0.5;
      this.ctx.beginPath();
      this.ctx.arc(0, 0, satellite.distance, 0, Math.PI * 2);
      this.ctx.stroke();
      this.ctx.setLineDash([]);
      
      // Draw the moon
      const moonGradient = this.ctx.createRadialGradient(
        pos.x, pos.y, 0,
        pos.x, pos.y, satellite.size
      );
      
      // Extract satellite color components
      const satColorRegex = /hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/;
      const satMatches = satellite.color.match(satColorRegex);
      
      if (satMatches) {
        const satHue = parseInt(satMatches[1]);
        const satSat = parseInt(satMatches[2]);
        const satLight = parseInt(satMatches[3]);
        
        moonGradient.addColorStop(0, `hsla(${satHue}, ${satSat}%, ${Math.min(100, satLight + 15)}%, 1)`);
        moonGradient.addColorStop(0.7, `hsla(${satHue}, ${satSat}%, ${satLight}%, 1)`);
        moonGradient.addColorStop(1, `hsla(${satHue}, ${Math.max(0, satSat - 10)}%, ${Math.max(0, satLight - 10)}%, 0.9)`);
      } else {
        // Fallback if color parsing fails
        moonGradient.addColorStop(0, 'rgba(200, 200, 200, 1)');
        moonGradient.addColorStop(0.7, 'rgba(160, 160, 160, 1)');
        moonGradient.addColorStop(1, 'rgba(120, 120, 120, 0.9)');
      }
      
      this.ctx.fillStyle = moonGradient;
      this.ctx.beginPath();
      this.ctx.arc(pos.x, pos.y, satellite.size, 0, Math.PI * 2);
      this.ctx.fill();
    }
  }
  
  private renderLifeForm(plant: Plant, hue: number, sat: number, light: number) {
    // Life forms become more complex with evolution
    const size = plant.size;
    const complexity = plant.lifeComplexity;
    
    // Draw base of life form - circular cell/body
    const bodyGradient = this.ctx.createRadialGradient(
      0, 0, 0,
      0, 0, size
    );
    
    bodyGradient.addColorStop(0, `hsla(${hue}, ${sat}%, ${Math.min(100, light + 10)}%, 1)`);
    bodyGradient.addColorStop(0.7, `hsla(${hue}, ${Math.max(0, sat - 5)}%, ${light}%, 1)`);
    bodyGradient.addColorStop(1, `hsla(${hue}, ${Math.max(0, sat - 15)}%, ${Math.max(0, light - 10)}%, 0.9)`);
    
    this.ctx.fillStyle = bodyGradient;
    this.ctx.beginPath();
    this.ctx.arc(0, 0, size, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Draw appendages/cilia/flagella based on complexity
    const appendageCount = 3 + Math.floor(complexity * 10);
    
    for (let i = 0; i < appendageCount; i++) {
      const angle = (i / appendageCount) * Math.PI * 2 + plant.oscillation * 0.1;
      const appendageLength = size * (0.5 + complexity * 0.7);
      const appendageWidth = size * (0.2 - complexity * 0.1); // Thinner with complexity
      
      // Create appendage gradient
      const appendageGradient = this.ctx.createLinearGradient(
        0, 0,
        Math.cos(angle) * appendageLength,
        Math.sin(angle) * appendageLength
      );
      
      appendageGradient.addColorStop(0, `hsla(${hue}, ${sat}%, ${light}%, 1)`);
      appendageGradient.addColorStop(1, `hsla(${hue}, ${Math.max(0, sat - 10)}%, ${Math.max(0, light - 15)}%, 0.7)`);
      
      this.ctx.fillStyle = appendageGradient;
      
      // Draw appendage
      this.ctx.save();
      this.ctx.translate(0, 0);
      this.ctx.rotate(angle);
      
      // With higher complexity, make more detailed appendages
      if (complexity < 0.3) {
        // Simple round appendages - like pseudopods
        this.ctx.beginPath();
        this.ctx.ellipse(
          appendageLength / 2, 0, 
          appendageLength / 2, appendageWidth,
          0, 0, Math.PI * 2
        );
        this.ctx.fill();
      } else if (complexity < 0.6) {
        // Segmented appendages - early multicellular
        const segmentCount = 3;
        const segmentLength = appendageLength / segmentCount;
        
        for (let j = 0; j < segmentCount; j++) {
          const segWidth = appendageWidth * (1 - j * 0.2);
          const xPos = j * segmentLength;
          
          this.ctx.beginPath();
          this.ctx.ellipse(
            xPos + segmentLength / 2, 0,
            segmentLength / 2, segWidth,
            0, 0, Math.PI * 2
          );
          this.ctx.fill();
        }
      } else {
        // Complex articulated appendages - higher organisms
        const segmentCount = 5;
        const segmentLength = appendageLength / segmentCount;
        let lastX = 0, lastY = 0;
        
        for (let j = 0; j < segmentCount; j++) {
          const segWidth = appendageWidth * (1 - j * 0.15);
          const xPos = j * segmentLength;
          // Add some wave motion to advanced appendages
          const yPos = Math.sin(plant.oscillation * 0.2 + j) * appendageWidth * 0.5;
          
          // Draw connecting segment if not first segment
          if (j > 0) {
            this.ctx.beginPath();
            this.ctx.moveTo(lastX, lastY);
            this.ctx.lineTo(xPos, yPos);
            this.ctx.lineWidth = segWidth * 1.5;
            this.ctx.strokeStyle = `hsla(${hue}, ${sat}%, ${light}%, 0.9)`;
            this.ctx.stroke();
          }
          
          // Draw segment node
          this.ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, 0.9)`;
          this.ctx.beginPath();
          this.ctx.arc(xPos, yPos, segWidth, 0, Math.PI * 2);
          this.ctx.fill();
          
          lastX = xPos;
          lastY = yPos;
        }
      }
      
      this.ctx.restore();
    }
    
    // Draw internal structures for complex life
    if (complexity > 0.4) {
      // Draw nucleus/core
      const coreSize = size * 0.4;
      const coreGradient = this.ctx.createRadialGradient(
        0, 0, 0,
        0, 0, coreSize
      );
      
      // Different color for the core
      const coreHue = (hue + 120) % 360;
      
      coreGradient.addColorStop(0, `hsla(${coreHue}, ${Math.min(100, sat + 20)}%, ${Math.min(100, light + 10)}%, 0.9)`);
      coreGradient.addColorStop(0.7, `hsla(${coreHue}, ${sat}%, ${light}%, 0.7)`);
      coreGradient.addColorStop(1, `hsla(${coreHue}, ${Math.max(0, sat - 10)}%, ${Math.max(0, light - 5)}%, 0.5)`);
      
      this.ctx.fillStyle = coreGradient;
      this.ctx.beginPath();
      this.ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
      this.ctx.fill();
      
      // For very complex life, add more organelles
      if (complexity > 0.7) {
        const organelleCount = 3 + Math.floor(Math.random() * 4);
        
        for (let i = 0; i < organelleCount; i++) {
          const angle = (i / organelleCount) * Math.PI * 2;
          const distance = size * 0.3;
          const organelleSize = size * 0.15;
          
          const x = Math.cos(angle) * distance;
          const y = Math.sin(angle) * distance;
          
          // Randomize the organelle color
          const organelleHue = (hue + 60 + Math.floor(Math.random() * 120)) % 360;
          
          const organelleGradient = this.ctx.createRadialGradient(
            x, y, 0,
            x, y, organelleSize
          );
          
          organelleGradient.addColorStop(0, `hsla(${organelleHue}, ${Math.min(100, sat + 10)}%, ${Math.min(100, light + 5)}%, 0.9)`);
          organelleGradient.addColorStop(0.7, `hsla(${organelleHue}, ${sat}%, ${light}%, 0.7)`);
          organelleGradient.addColorStop(1, `hsla(${organelleHue}, ${Math.max(0, sat - 10)}%, ${Math.max(0, light - 5)}%, 0.5)`);
          
          this.ctx.fillStyle = organelleGradient;
          this.ctx.beginPath();
          this.ctx.arc(x, y, organelleSize, 0, Math.PI * 2);
          this.ctx.fill();
        }
      }
    }
  }
}
      
      // Draw each segment with enhanced style
      let prevX = 0;
      let prevY = 0;
      
      for (let i = 0; i < branch.segments.length; i++) {
        const segment = branch.segments[i];
        const segmentWidth = branch.width * (1 - i / branch.segments.length) * (1 + Math.sin(plant.oscillation + i) * 0.1);
        
        // Calculate end points
        const endX = segment.x + Math.cos(segment.angle) * segment.length;
        const endY = segment.y + Math.sin(segment.angle) * segment.length;
        
        // Create segment gradient
        const segmentGradient = this.ctx.createLinearGradient(
          segment.x, segment.y, 
          endX, endY
        );
        
        segmentGradient.addColorStop(0, `hsla(${hue - 10}, ${sat}%, ${light + 5}%, 1)`);
        segmentGradient.addColorStop(1, `hsla(${hue + 10}, ${sat - 10}%, ${light}%, 1)`);
        
        // Draw segment as line with shadow
        this.ctx.shadowColor = `hsla(${hue}, ${sat}%, ${light + 20}%, 0.4)`;
        this.ctx.shadowBlur = 5;
        this.ctx.lineWidth = segmentWidth;
        this.ctx.lineCap = 'round';
        this.ctx.strokeStyle = segmentGradient;
        
        this.ctx.beginPath();
        this.ctx.moveTo(segment.x, segment.y);
        this.ctx.lineTo(endX, endY);
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        
        // Draw a decoration at the segment joints
        if (i > 0) {
          const jointGradient = this.ctx.createRadialGradient(
            segment.x, segment.y, 0,
            segment.x, segment.y, segmentWidth * 0.8
          );
          
          jointGradient.addColorStop(0, `hsla(${hue + 15}, ${sat + 10}%, ${light + 15}%, 1)`);
          jointGradient.addColorStop(1, `hsla(${hue}, ${sat}%, ${light}%, 1)`);
          
          this.ctx.fillStyle = jointGradient;
          this.ctx.beginPath();
          this.ctx.arc(segment.x, segment.y, segmentWidth * 0.8, 0, Math.PI * 2);
          this.ctx.fill();
        }
        
        prevX = endX;
        prevY = endY;
      }
      
      // Draw an enhanced flower at the end of the last segment
      if (branch.segments.length > 0) {
        const lastSegment = branch.segments[branch.segments.length - 1];
        const endX = lastSegment.x + Math.cos(lastSegment.angle) * lastSegment.length;
        const endY = lastSegment.y + Math.sin(lastSegment.angle) * lastSegment.length;
        
        // Flower size with gentle pulsing
        const decorationSize = branch.width * 0.9 * (1 + Math.sin(plant.oscillation * 2) * 0.1);
        
        // Create a more vibrant petal color
        const petalGradient = this.ctx.createRadialGradient(
          endX, endY, decorationSize * 0.5,
          endX, endY, decorationSize * 2
        );
        
        petalGradient.addColorStop(0, `hsla(${hue + 10}, ${sat + 15}%, ${light + 20}%, 0.9)`);
        petalGradient.addColorStop(0.7, `hsla(${hue}, ${sat + 5}%, ${light + 10}%, 0.8)`);
        petalGradient.addColorStop(1, `hsla(${hue - 10}, ${sat}%, ${light}%, 0.7)`);
        
        this.ctx.fillStyle = petalGradient;
        this.ctx.shadowColor = `hsla(${hue}, ${sat}%, ${light + 20}%, 0.5)`;
        this.ctx.shadowBlur = 10;
        this.ctx.beginPath();
        
        // Draw a more detailed flower with 6 petals
        const petalCount = 6;
        for (let i = 0; i < petalCount; i++) {
          const angle = (i / petalCount) * Math.PI * 2;
          // Add slight randomization to petal shape
          const petalLength = decorationSize * (1.5 + Math.sin(plant.oscillation + i) * 0.2);
          const petalWidth = decorationSize * (0.8 + Math.cos(plant.oscillation + i * 2) * 0.1);
          
          const petalX = endX + Math.cos(angle) * petalLength;
          const petalY = endY + Math.sin(angle) * petalLength;
          
          const ctrl1X = endX + Math.cos(angle - 0.2) * petalLength * 0.8;
          const ctrl1Y = endY + Math.sin(angle - 0.2) * petalLength * 0.8;
          
          const ctrl2X = endX + Math.cos(angle + 0.2) * petalLength * 0.8;
          const ctrl2Y = endY + Math.sin(angle + 0.2) * petalLength * 0.8;
          
          this.ctx.moveTo(endX, endY);
          this.ctx.bezierCurveTo(
            ctrl1X, ctrl1Y,
            ctrl2X, ctrl2Y,
            petalX, petalY
          );
          this.ctx.bezierCurveTo(
            endX + Math.cos(angle + 0.4) * petalWidth,
            endY + Math.sin(angle + 0.4) * petalWidth,
            endX + Math.cos(angle - 0.4) * petalWidth,
            endY + Math.sin(angle - 0.4) * petalWidth,
            endX, endY
          );
        }
        
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Add a glowing center to the flower
        const centerGradient = this.ctx.createRadialGradient(
          endX, endY, 0,
          endX, endY, decorationSize * 0.7
        );
        
        // Complementary color for center
        const centerHue = (hue + 180) % 360;
        centerGradient.addColorStop(0, `hsla(${centerHue}, ${sat + 20}%, ${light + 25}%, 1)`);
        centerGradient.addColorStop(0.6, `hsla(${centerHue}, ${sat + 10}%, ${light + 15}%, 0.9)`);
        centerGradient.addColorStop(1, `hsla(${centerHue}, ${sat}%, ${light + 5}%, 0.8)`);
        
        this.ctx.fillStyle = centerGradient;
        this.ctx.shadowColor = `hsla(${centerHue}, ${sat}%, ${light + 30}%, 0.7)`;
        this.ctx.shadowBlur = 15;
        this.ctx.beginPath();
        this.ctx.arc(endX, endY, decorationSize * 0.7, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Add some small decoration dots
        this.ctx.fillStyle = `hsla(${centerHue + 30}, ${sat + 30}%, ${light + 30}%, 0.9)`;
        this.ctx.shadowBlur = 3;
        
        for (let i = 0; i < 8; i++) {
          const dotAngle = (i / 8) * Math.PI * 2 + plant.oscillation * 0.5;
          const dotDist = decorationSize * 0.4;
          const dotX = endX + Math.cos(dotAngle) * dotDist;
          const dotY = endY + Math.sin(dotAngle) * dotDist;
          
          this.ctx.beginPath();
          this.ctx.arc(dotX, dotY, decorationSize * 0.1, 0, Math.PI * 2);
          this.ctx.fill();
        }
        
        // Occasional sparkles
        if (Math.random() < 0.1) {
          this.ctx.fillStyle = `rgba(255, 255, 220, ${0.7 + Math.sin(plant.oscillation) * 0.3})`;
          this.ctx.shadowColor = 'rgba(255, 255, 200, 0.8)';
          this.ctx.shadowBlur = 5;
          
          const sparkleCount = 2 + Math.floor(Math.random() * 3);
          for (let i = 0; i < sparkleCount; i++) {
            const sparkleAngle = Math.random() * Math.PI * 2;
            const sparkleDistance = Math.random() * decorationSize * 1.2;
            const sparkleX = endX + Math.cos(sparkleAngle) * sparkleDistance;
            const sparkleY = endY + Math.sin(sparkleAngle) * sparkleDistance;
            const sparkleSize = (0.5 + Math.random()) * decorationSize * 0.15;
            
            this.ctx.beginPath();
            this.ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
            this.ctx.fill();
          }
        }
        
        this.ctx.shadowBlur = 0;
      }
      
      this.ctx.restore();
    }
    
    this.ctx.restore();
  }
}
